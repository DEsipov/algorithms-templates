#!-*-coding:utf-8-*-
__author__ = 'vi'


def broken_search(nums, target) -> int:
    """Бинарный поиск в 'сломанном' списке.
    Args:
        nums (List): массив, бывший отсортированным в кольцевой структуре
        target ([type]): искомый эл-т
    Returns:
        int: индекс искомого эл-та, или -1 если не найден

    Алгоритм поиска:
    Массив делится на две части посередине.

    Одна точно должна быть упорядоченна.

    Если часть отсортирована, легко проверяется, входит ли в неё X.

    Итого:
    За left, right берутся индексы первого и последнего эл-тов.

    В цикле пока диапазон не схлопнется:
    Делим на части.
    Проверяем mid == X.
    Если левая сортирована:
        если X входит:
            индексы левой для след. итерации
        иначе:
            индексы правой для след. итерации
    иначе:
        если X входит:
            индексы правой для след. итерации
        иначе:
            индексы левой для след. итерации
    след. итерация
    При сужении диапазона до двух эл-тов, проверка на сортированность
    сравнивает один и тот же эл-т с собой. В условии необходимо '='.
    """
    # Указатели левой и правой границы массива. т.е. начало и конец.
    left, right = ...

    # Пока не схлопнутся. Т.е. пока левая граница меньше или равно правой.
    # И их мы в циклам двигаем, если что.
    while ...:

        # Берем опорный элемент из серединки. Проверяем, не искомый ли он?
        mid = ...
        if ...:
            return mid

        # Левая половинка.
        # Если указатель меньше опорного, значит отсортированная половинка.
        if ...:
            # Если target больше левого указателя и меньше опорного.
            # Т.е. попадает в левую половинку.
            # То правый указатель сдвигаем к опорному,
            # короче ищем только на левой половине.
            if nums[left] <= target < nums[mid]:
                right = ...
            else:
                # Иначе сдвигаем левый указатель к опорному.
                # Т.е. ищем только на правой половине
                left = mid + 1
        else:
            # Аналогично и с правой частью.
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1
